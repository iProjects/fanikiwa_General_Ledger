//====================================================================================================
// Code generated with Motion: BC Gen (Build 2.2.4750.27570)
// Layered Architecture Solution Guidance (http://layerguidance.codeplex.com)
//
// Generated by francis.muraya at KPC7070W on 08/07/2013 13:30:51 
//====================================================================================================

using fanikiwaGL.Data;
using fanikiwaGL.Entities;
using fanikiwaGL.Framework;
using fanikiwaGL.Framework.ExceptionHandlers;
using fanikiwaGL.Framework.ExceptionTypes;
using fanikiwaGL.Framework.Instrumentation;
using Microsoft.Practices.EnterpriseLibrary.Logging;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.Tracing;
using System.Linq;
using System.Runtime.Serialization;
using System.Web;
using TX = System.Transactions;

namespace fanikiwaGL.Business
{

    /// <summary>
    /// Posting business component.
    /// </summary>
    public partial class FinancialPostingComponent
    {


        #region "Posting"
        /// <summary>
        /// Post business method. 
        /// </summary>
        /// <param name="account">A account value.</param>
        /// <param name="transaction">A transaction value.</param>
        /// 

        public void BatchPostWithSimulation(List<Transaction> Trans)
        {
            BatchSimulateStatus bss = SimulatePostBatch(Trans);
            if (!bss.CanPost)
            {
                throw new BatchSimulationException(bss, "Posting Validation Failed");
            }

            BatchPost(Trans);
        }
        public bool BatchPost(List<Transaction> Trans, PostingLimitCheckFlag limitCheck)
        {
            if (ZeroProof(Trans))
            {
                using (System.Transactions.TransactionScope scope = new TX.TransactionScope())
                {
                    //How do we do transaction handling here
                    foreach (Transaction tx in Trans)
                    {
                        PostSingle(tx, limitCheck);
                    }
                    scope.Complete();
                }
                return true;

            }
            else
            {
                throw new PostingException("Batch does not balance");
            }
        }

        public bool BatchPost(List<Transaction> Trans)
        {
            return BatchPost(Trans, PostingLimitCheckFlag.CheckLimitPassFlag); //strongest level of limit check
        }

        public void PostSingle(Transaction transaction)
        {
            PostSingle(transaction, PostingLimitCheckFlag.CheckLimitPassFlag);
        }
        public void PostSingle(Transaction transaction, PostingLimitCheckFlag limitCheck)
        {

            
                //Step 0 - Check valid arguments
                if (transaction == null) throw new ArgumentNullException("Transaction");

                AccountDAC accountDAC = new AccountDAC();
                Account act = accountDAC.SelectById(transaction.AccountID);
                if (act == null)
                {
                    throw new ArgumentNullException("Account", "Account does not exist " + transaction.AccountID);
                }

                TransactionTypeDAC ttDac = new TransactionTypeDAC();
                TransactionType _TransactionType = ttDac.SelectById(transaction.TransactionTypeId);
                if (_TransactionType == null)
                {
                    throw new ArgumentNullException("TransactionType", "TransactionType does not exist " + transaction.TransactionTypeId);
                }

                switch (limitCheck)
                {
                    case PostingLimitCheckFlag.ForcePost:
                        //Does not check anything, it just inserts the transaction
                        InserTransaction(transaction, act);
                        break;
                    case PostingLimitCheckFlag.NoLimitCheck:// does not check limit but checks PassFlag
                        SimulatePostStatus simulate = SimulatePostSingle(transaction);
                        //foreach (var e in status.Errors)
                        //{
                        //    if (e is LimitException) status.Errors.Remove(e);
                        //}
                        simulate.Errors.RemoveAll(a => a is LimitException);
                        if (simulate.CanPost)
                        {
                            InserTransaction(transaction, act);
                        }
                        else
                        {
                            if (simulate.Errors.Count() > 0) throw simulate.Errors.First();
                        }
                        break;
                    case PostingLimitCheckFlag.CheckLimitFlagOnly:// Checks account limit status and not PassFlag
                        SimulatePostStatus simulate2 = SimulatePostSingle(transaction);
                        simulate2.Errors.RemoveAll(a => a is AccountLockException);
                        if (simulate2.CanPost)
                        {
                            InserTransaction(transaction, act);
                        }
                        else
                        {
                            if (simulate2.Errors.Count() > 0) throw simulate2.Errors.First();
                        }
                        break;
                    case PostingLimitCheckFlag.CheckLimitPassFlag:// Checks account limit status and PassFlag
                        SimulatePostStatus simulate3 = SimulatePostSingle(transaction);
                        if (simulate3.CanPost)
                        {
                            InserTransaction(transaction, act);
                        }
                        else
                        {
                            if (simulate3.Errors.Count() > 0) throw simulate3.Errors.First();
                        }
                        break;
                }

                    
            }


        private void InserTransaction(Transaction transaction, Account act)
        {
            //all these steps must be done in a transaction coz they are ACID
            using (System.Transactions.TransactionScope scope = new TX.TransactionScope())
            {
                AccountDAC accountDAC = new AccountDAC();

                // Step 1 - Insert new transaction.
                TransactionDAC tDAC = new TransactionDAC();
                if (transaction.ValueDate == DateTime.MinValue) transaction.ValueDate = transaction.PostDate;
                tDAC.Create(transaction);

                // Step 3 - Update balance and value date.

                //On Before Book Balance Changed
                act.BookBalance += transaction.Amount;

                //If postdate == valuedate clear the funds immediately
                if (transaction.ValueDate == transaction.PostDate)
                {
                    //On Before Cleared Balance Changed
                    //StaticPostingComponent.ClearEffects(Account account, decimal amount)
                    act.ClearedBalance += transaction.Amount;
                }
                else if (transaction.ValueDate > transaction.PostDate)
                {
                    //this is a value dated transaction, 
                    //enter a valuedated diary record if a diary 

                    ValueDatedTransaction vt = new ValueDatedTransaction();
                    vt.AccountID = transaction.AccountID;
                    vt.Amount = transaction.Amount;
                    vt.Authorizer = transaction.Authorizer;
                    vt.ForcePostFlag = transaction.ForcePostFlag;
                    vt.Narrative = transaction.Narrative;
                    vt.PostDate = transaction.PostDate;
                    vt.RecordDate = transaction.RecordDate;
                    vt.StatementFlag = transaction.StatementFlag;
                    vt.TransactionID = transaction.TransactionID;
                    vt.TransactionTypeId = transaction.TransactionTypeId;
                    vt.UserID = transaction.UserID;
                    vt.ValueDate = transaction.ValueDate;

                    ValueDatedTransactionDAC vDac = new ValueDatedTransactionDAC();
                    vDac.Create(vt);

                }
                else
                {
                    throw new NotImplementedException("Back dated transactions not supported");
                }

                accountDAC.UpdateById(act);
                scope.Complete();
            }
        }
        #endregion "Posting"

        #region "Simulate Post"
        public BatchSimulateStatus SimulatePostBatch(List<Transaction> transactions)
        {
            List<SimulatePostStatus> SimulateStatus = new List<SimulatePostStatus>();
            foreach (var tx in transactions)
            {
                SimulateStatus.Add(SimulatePostSingle(tx));
            }

            return new BatchSimulateStatus(SimulateStatus);
 
        }
        public SimulatePostStatus SimulatePostSingle(Transaction transaction)
        {

            SimulatePostStatus result = new SimulatePostStatus();

            //Step 0 - Check valid arguments
            if (transaction == null)
            {
                result.Errors.Add(new ArgumentNullException("Transaction"));
                 return result;
            }

            result.AccountID = transaction.AccountID;
            result.TransactionAmount = transaction.Amount;
            result.TransactionTypeId = transaction.TransactionTypeId;

            AccountDAC accountDAC = new AccountDAC();
            Account act = accountDAC.SelectById(transaction.AccountID);
            if (act == null)
            {
                result.Errors.Add(new ArgumentNullException("Account", "Account does not exist " + transaction.AccountID));
                return result;
            }

            if (act.Closed)
            {
                result.Errors.Add(new ArgumentNullException("Account", "Account closed " + transaction.AccountID));
                return result;
            }

            TransactionTypeDAC ttDac = new TransactionTypeDAC();
            TransactionType _TransactionType = ttDac.SelectById(transaction.TransactionTypeId);
            if (_TransactionType == null)
            {
                result.Errors.Add(new ArgumentNullException("TransactionType", "TransactionType does not exist " + transaction.TransactionTypeId));
                return result;
            }

            // Step 1 - See if we can post into this account by looking at lock and limit flags.

            decimal AmountAvailable = act.ClearedBalance - act.Limit;
            decimal UnclearedEffects = act.BookBalance - act.ClearedBalance;
            decimal AmountAvailableOnUncleared = act.BookBalance - act.Limit;
            decimal AmountAvailableAfterTxn = act.ClearedBalance + transaction.Amount;

            result.BookBalanceBeforePosting = act.BookBalance;
            result.ClearedBalanceBeforePosting = act.ClearedBalance;
            result.Limit = act.Limit;

            StaticTransactionsComponent acEnquiry = new StaticTransactionsComponent();
            AccountLimitStatus limistatus = acEnquiry.GetAccountLimitStatus(act);
            PassFlag lockstatus = acEnquiry.GetAccountLockStatus(act);
            result.BlockedStatus = lockstatus;
            result.LimitStatus = limistatus;


            //Do account status tests only if the transaction is not a force post
            if (!transaction.ForcePostFlag)
            {
                //check 1 - Lock status
                if ((lockstatus == PassFlag.Locked)
                    || (lockstatus == PassFlag.AllPostingProhibited)
                    || (lockstatus == PassFlag.CreditPostingProhibited && _TransactionType.DebitCredit.Equals("C"))
                    || (lockstatus == PassFlag.DebitPostingProhibited && _TransactionType.DebitCredit.Equals("D"))
                    )
                {
                    result.Errors.Add(new AccountLockException("Account [{0}] posting prohibited.\nAccount lock status =[{2}]",
                        act.AccountID,
                        _TransactionType.TransactionTypeID,
                        lockstatus.ToString()));
                    return result;
                }

                //check 2 - Limit status
                if ((limistatus == AccountLimitStatus.PostingOverDrawingProhibited && AmountAvailableAfterTxn < 0)
                    || (limistatus == AccountLimitStatus.PostingDrawingOnUnclearedEffectsAllowed && AmountAvailableOnUncleared < 0)
                    )
                {
                    result.Errors.Add(new LimitException("Account [{0}] overdraw prohibited, limit status =[{2}]",
                        act.AccountID,
                        _TransactionType.TransactionTypeID,
                        limistatus.ToString()// Enum.GetName(typeof(AccountStatus), limistatus))
                        ));
                    return result;
                }
            }

            return result;
        }
        #endregion "Simulate Post"

        #region "Private Methods"
        private bool ZeroProof(List<Transaction> Trans)
        {
            bool isProofed = false;

            decimal total = 0;

            //loop through all the items in the list
            foreach (Transaction t in Trans) total += t.Amount;

            isProofed = total.Equals(0);

            return isProofed;
        }
        #endregion "Private Methods"



    }


}
